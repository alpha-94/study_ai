import numpy as np

# Vector(1차원 배열)
X = np.array([1,2,3,4,5])
print(X.shape) # (5,)

# 3X2 행렬과 2X3 행렬의 내적(Matrix : 2차원 배열)
A = np.array([[1,2],[3,4],[5,6]])
print(A.shape) #(3, 2) 3행 2열

B = np.array([[1,2,3],[4,5,6]])
print(B.shape) #(2,3) 2행 3열

Z = np.dot(A,B)
print(Z)
"""
[[ 9 12 15]
 [19 26 33]
 [29 40 51]]
"""

# Array(3차원 배열 이상) 2면 3행 4열
K = [[1,2,3,4],[5,6,7,8],[9,10,11,12]],[[13,14,15,16],[5,6,7,8],[9,10,11,12]]
X = np.array(K)
print(X.shape) #(2, 3, 4)
print((np.ndim(X))) # 차원 정보 : 3 (차원)

# 교환 법칙 성립 X
# 교환법칙? 연산의 순서를 바꿔 계산할 때 그 결과가 동일하면 교환법칙이 성립
# np.dot(A,B) 3행 3열 != np.dot(B,A) 2행 2열. 구조가 다르기 때문에 교환법칙이 성립하지 않음
Z = np.dot(B,A)
print(Z) #2행 2열
"""
[[22 28]
 [49 64]]
"""

print()
# A가 2차원 행렬, B가 1차원 배열 곱
A = np.array([[1,2],[3,4],[5,6]]) #3행 2열
B = np.array([7,8]) #1행 2열 ->
print(B.shape) #(2,)
print(A.shape) #(3, 2)
print(np.dot(A,B)) #[23 53 83]
#원칙상 A의 열의 크기가 B의 행의 크기와 동일해야 내적 가능하나, 아니여도 출력 (3행2열)(2행1열)로 변경

# 신경망의 내적
X = np.array([1,2]) # x1 = 1, x2 = 2
W = np.array([[1,3,5],[2,4,6]])
Y = np.dot(X,W) #<1행 2열> X <2행 3열> 로 계산


